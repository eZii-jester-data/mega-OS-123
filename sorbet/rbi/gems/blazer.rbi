# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/blazer/all/blazer.rbi
#
# blazer-2.2.1
module Blazer
  def self.adapters; end
  def self.anomaly_checks; end
  def self.anomaly_checks=(arg0); end
  def self.async; end
  def self.async=(arg0); end
  def self.audit; end
  def self.audit=(arg0); end
  def self.before_action; end
  def self.before_action=(arg0); end
  def self.cache; end
  def self.cache=(arg0); end
  def self.check_schedules; end
  def self.check_schedules=(arg0); end
  def self.data_sources; end
  def self.extract_vars(statement); end
  def self.forecasting; end
  def self.forecasting=(arg0); end
  def self.from_email; end
  def self.from_email=(arg0); end
  def self.images; end
  def self.images=(arg0); end
  def self.mapbox_access_token; end
  def self.mapbox_access_token=(arg0); end
  def self.override_csp; end
  def self.override_csp=(arg0); end
  def self.query_editable; end
  def self.query_editable=(arg0); end
  def self.query_viewable; end
  def self.query_viewable=(arg0); end
  def self.railtie_helpers_paths; end
  def self.railtie_namespace; end
  def self.railtie_routes_url_helpers(include_path_helpers = nil); end
  def self.register_adapter(name, adapter); end
  def self.run_check(check); end
  def self.run_checks(schedule: nil); end
  def self.send_failing_checks; end
  def self.settings; end
  def self.slack?; end
  def self.slack_webhook_url; end
  def self.slack_webhook_url=(arg0); end
  def self.table_name_prefix; end
  def self.time_zone; end
  def self.time_zone=(time_zone); end
  def self.transform_statement; end
  def self.transform_statement=(arg0); end
  def self.transform_variable; end
  def self.transform_variable=(arg0); end
  def self.use_relative_model_naming?; end
  def self.user_class; end
  def self.user_class=(arg0); end
  def self.user_method; end
  def self.user_method=(arg0); end
  def self.user_name; end
  def self.user_name=(arg0); end
end
class Blazer::DataSource
  def adapter; end
  def adapter_instance; end
  def cache; end
  def cache_expires_in; end
  def cache_key(key); end
  def cache_mode; end
  def cache_slow_threshold; end
  def cancel(*args, &block); end
  def clear_cache(statement); end
  def cost(*args, &block); end
  def delete_results(run_id); end
  def detect_adapter; end
  def explain(*args, &block); end
  def id; end
  def initialize(id, settings); end
  def linked_columns; end
  def local_time_suffix; end
  def name; end
  def preview_statement(*args, &block); end
  def read_cache(cache_key); end
  def reconnect(*args, &block); end
  def run_cache_key(run_id); end
  def run_results(run_id); end
  def run_statement(statement, options = nil); end
  def run_statement_helper(statement, comment, run_id); end
  def schema(*args, &block); end
  def settings; end
  def smart_columns; end
  def smart_variables; end
  def statement_cache_key(statement); end
  def tables(*args, &block); end
  def timeout; end
  def variable_defaults; end
  extend Forwardable
end
class Blazer::Result
  def anomaly?(series); end
  def boom; end
  def cached?; end
  def cached_at; end
  def chart_type; end
  def column_types; end
  def columns; end
  def data_source; end
  def detect_anomaly; end
  def error; end
  def forecast; end
  def forecast_error; end
  def forecastable?; end
  def initialize(data_source, columns, rows, error, cached_at, just_cached); end
  def just_cached; end
  def rows; end
  def timed_out?; end
end
class Blazer::RunStatement
  def perform(data_source, statement, options = nil); end
end
module Blazer::Adapters
end
class Blazer::Adapters::BaseAdapter
  def cachable?(statement); end
  def cancel(run_id); end
  def cost(statement); end
  def data_source; end
  def explain(statement); end
  def initialize(data_source); end
  def preview_statement; end
  def reconnect; end
  def run_statement(statement, comment); end
  def schema; end
  def settings; end
  def tables; end
end
class Blazer::Adapters::AthenaAdapter < Blazer::Adapters::BaseAdapter
  def client; end
  def database; end
  def fetch_error(query_execution_id); end
  def glue; end
  def preview_statement; end
  def run_statement(statement, comment); end
  def schema; end
  def tables; end
end
class Blazer::Adapters::BigQueryAdapter < Blazer::Adapters::BaseAdapter
  def bigquery; end
  def preview_statement; end
  def run_statement(statement, comment); end
  def schema; end
  def table_columns(table_ref); end
  def table_refs; end
  def tables; end
end
class Blazer::Adapters::CassandraAdapter < Blazer::Adapters::BaseAdapter
  def cluster; end
  def keyspace; end
  def preview_statement; end
  def run_statement(statement, comment); end
  def schema; end
  def session; end
  def tables; end
  def uri; end
end
class Blazer::Adapters::DrillAdapter < Blazer::Adapters::BaseAdapter
  def drill; end
  def run_statement(statement, comment); end
end
class Blazer::Adapters::DruidAdapter < Blazer::Adapters::BaseAdapter
  def preview_statement; end
  def run_statement(statement, comment); end
  def schema; end
  def tables; end
end
class Blazer::Adapters::ElasticsearchAdapter < Blazer::Adapters::BaseAdapter
  def client; end
  def preview_statement; end
  def run_statement(statement, comment); end
  def tables; end
end
class Blazer::Adapters::MongodbAdapter < Blazer::Adapters::BaseAdapter
  def client; end
  def db; end
  def preview_statement; end
  def run_statement(statement, comment); end
  def tables; end
end
class Blazer::Adapters::Neo4jAdapter < Blazer::Adapters::BaseAdapter
  def preview_statement; end
  def run_statement(statement, comment); end
  def session; end
  def tables; end
end
class Blazer::Adapters::PrestoAdapter < Blazer::Adapters::BaseAdapter
  def client; end
  def preview_statement; end
  def run_statement(statement, comment); end
  def tables; end
end
class Blazer::Adapters::SalesforceAdapter < Blazer::Adapters::BaseAdapter
  def client; end
  def preview_statement; end
  def run_statement(statement, comment); end
  def tables; end
end
class Blazer::Adapters::SqlAdapter < Blazer::Adapters::BaseAdapter
  def adapter_name; end
  def add_schemas(query); end
  def cachable?(statement); end
  def cancel(run_id); end
  def connection_model; end
  def cost(statement); end
  def default_schema; end
  def execute(statement); end
  def explain(statement); end
  def in_transaction; end
  def initialize(data_source); end
  def mysql?; end
  def postgresql?; end
  def preview_statement; end
  def reconnect; end
  def redshift?; end
  def run_statement(statement, comment); end
  def schema; end
  def select_all(statement, params = nil); end
  def set_timeout(timeout); end
  def snowflake?; end
  def sqlserver?; end
  def tables; end
  def use_transaction?; end
end
class Blazer::Adapters::SnowflakeAdapter < Blazer::Adapters::SqlAdapter
  def cancel(run_id); end
  def initialize(data_source); end
end
class Blazer::Engine < Rails::Engine
end
class Blazer::Error < StandardError
end
class Blazer::TimeoutNotSupported < Blazer::Error
end
