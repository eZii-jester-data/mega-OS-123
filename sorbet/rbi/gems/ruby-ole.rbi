# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ruby-ole/all/ruby-ole.rbi
#
# ruby-ole-1.2.12.2
class String
  def each_chunk(size); end
end
class File < IO
end
class Symbol
end
module Enumerable
end
class IO
  def self.open(*arg0); end
end
class Logger
  def self.new_with_callstack(logdev = nil); end
end
module RecursivelyEnumerable
  def each_recursive(mode = nil, &block); end
  def each_recursive_breadth_first(&block); end
  def each_recursive_depth_first(&block); end
  def recursive(mode = nil); end
  def to_tree(io = nil, &inspect); end
end
module Ole
end
class Ole::IOMode
  def append?; end
  def binary?; end
  def create?; end
  def flags; end
  def initialize(flags); end
  def inspect; end
  def readable?; end
  def self.parse_mode(mode); end
  def truncate?; end
  def writeable?; end
  include Ole::IOMode::Constants
end
module Ole::IOMode::Constants
  include File::Constants
end
class Ole::Storage
  def bat_for_size(size); end
  def bbat; end
  def clear; end
  def close; end
  def close_parent; end
  def dir; end
  def dirent_from_path(path); end
  def dirents; end
  def file; end
  def flush; end
  def header; end
  def initialize(arg, mode = nil, params = nil); end
  def inspect; end
  def io; end
  def load; end
  def meta_data; end
  def params; end
  def repack(temp = nil); end
  def repack_using_io(temp_io); end
  def root; end
  def sb_file; end
  def sbat; end
  def self.open(arg, mode = nil, params = nil); end
  def writeable; end
end
module Ole::Types
  def self.load_guid(str); end
  def self.load_time(str); end
  include Ole::Types::Variant::Constants
end
class Ole::Types::Data < String
  def self.dump(str); end
  def self.load(str); end
end
class Ole::Types::Lpstr < String
  def self.dump(str); end
  def self.load(str); end
end
class Ole::Types::Iconv
  def iconv(str); end
  def initialize(to, from); end
end
class Ole::Types::Lpwstr < String
  def self.dump(str); end
  def self.load(str); end
end
class Ole::Types::FileTime < DateTime
  def inspect; end
  def self.dump(time); end
  def self.from_time(time); end
  def self.load(str); end
  def self.now; end
end
class Ole::Types::Clsid < String
  def format; end
  def inspect; end
  def self.dump(guid); end
  def self.load(str); end
  def self.parse(str); end
end
module Ole::Types::Variant
  def self.dump(type, variant); end
  def self.load(type, str); end
end
module Ole::Types::Variant::Constants
end
class Ole::Types::PropertySet
  def [](key); end
  def []=(key, value); end
  def each; end
  def guid; end
  def initialize(io); end
  def io; end
  def load_header(str); end
  def load_section_list(str); end
  def method_missing(name, *args, &block); end
  def os; end
  def sections; end
  def signature; end
  def to_h; end
  def unknown; end
  include Enumerable
  include Ole::Types::PropertySet::Constants
end
module Ole::Types::PropertySet::Constants
end
class Ole::Types::PropertySet::Section
  def [](key); end
  def []=(key, value); end
  def each; end
  def each_raw; end
  def guid; end
  def guid=(arg0); end
  def initialize(str, property_set); end
  def io; end
  def length; end
  def load_header; end
  def offset; end
  def offset=(arg0); end
  def read_property(property_offset); end
  include Enumerable
  include Ole::Types::Variant::Constants
end
class RangesIO
  def <<(data); end
  def close; end
  def eof?; end
  def gets; end
  def initialize(io, mode = nil, params = nil); end
  def inspect; end
  def io; end
  def mode; end
  def pos; end
  def pos=(pos, whence = nil); end
  def ranges; end
  def ranges=(ranges); end
  def read(limit = nil); end
  def readline; end
  def rewind; end
  def seek(pos, whence = nil); end
  def self.open(*args, &block); end
  def size; end
  def size=(size); end
  def tell; end
  def truncate(size); end
  def write(data); end
end
class RangesIONonResizeable < RangesIO
  def initialize(io, mode = nil, params = nil); end
end
class Ole::Storage::FormatError < StandardError
end
class Anonymous_Struct_20 < Struct
  def b_shift; end
  def b_shift=(_); end
  def byte_order; end
  def byte_order=(_); end
  def clsid; end
  def clsid=(_); end
  def csectdir; end
  def csectdir=(_); end
  def dirent_start; end
  def dirent_start=(_); end
  def magic; end
  def magic=(_); end
  def major_ver; end
  def major_ver=(_); end
  def mbat_start; end
  def mbat_start=(_); end
  def minor_ver; end
  def minor_ver=(_); end
  def num_bat; end
  def num_bat=(_); end
  def num_mbat; end
  def num_mbat=(_); end
  def num_sbat; end
  def num_sbat=(_); end
  def reserved; end
  def reserved=(_); end
  def s_shift; end
  def s_shift=(_); end
  def sbat_start; end
  def sbat_start=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def threshold; end
  def threshold=(_); end
  def transacting_signature; end
  def transacting_signature=(_); end
end
class Ole::Storage::Header < Anonymous_Struct_20
  def initialize(values = nil); end
  def to_s; end
  def validate!; end
end
class Ole::Storage::AllocationTable < Array
  def []=(idx, val); end
  def block_size; end
  def blocks_to_ranges(chain, size = nil); end
  def chain(idx); end
  def collect!(*args, &block); end
  def free_block; end
  def initialize(ole); end
  def io; end
  def load(data); end
  def map!(*args, &block); end
  def ole; end
  def open(chain, size = nil, &block); end
  def ranges(chain, size = nil); end
  def read(chain, size = nil); end
  def resize_chain(blocks, size); end
  def to_s; end
  def truncate!; end
  def truncate; end
end
class Ole::Storage::AllocationTable::Big < Ole::Storage::AllocationTable
  def blocks_to_ranges(chain, size = nil); end
  def initialize(*args); end
end
class Ole::Storage::AllocationTable::Small < Ole::Storage::AllocationTable
  def initialize(*args); end
end
class Ole::Storage::RangesIOResizeable < RangesIO
  def bat; end
  def first_block; end
  def first_block=(arg0); end
  def initialize(bat, mode = nil, params = nil); end
  def truncate(size); end
end
class Ole::Storage::RangesIOMigrateable < Ole::Storage::RangesIOResizeable
  def dirent; end
  def first_block; end
  def first_block=(val); end
  def initialize(dirent, mode = nil); end
  def truncate(size); end
end
class Anonymous_Struct_21 < Struct
  def child; end
  def child=(_); end
  def clsid; end
  def clsid=(_); end
  def colour; end
  def colour=(_); end
  def create_time_str; end
  def create_time_str=(_); end
  def first_block; end
  def first_block=(_); end
  def flags; end
  def flags=(_); end
  def modify_time_str; end
  def modify_time_str=(_); end
  def name_len; end
  def name_len=(_); end
  def name_utf16; end
  def name_utf16=(_); end
  def next; end
  def next=(_); end
  def prev; end
  def prev=(_); end
  def reserved; end
  def reserved=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def size; end
  def size=(_); end
  def type_id; end
  def type_id=(_); end
end
class Ole::Storage::Dirent < Anonymous_Struct_21
  def /(name); end
  def <<(child); end
  def [](idx); end
  def children; end
  def create_time; end
  def delete(child, truncate = nil); end
  def dir?; end
  def each_child(&block); end
  def file?; end
  def flatten(dirents = nil); end
  def idx; end
  def idx=(arg0); end
  def initialize(ole, values = nil, params = nil); end
  def inspect; end
  def modify_time; end
  def name; end
  def name=(name); end
  def name_lookup; end
  def ole; end
  def open(mode = nil); end
  def parent; end
  def parent=(arg0); end
  def read(limit = nil); end
  def self.copy(src, dst); end
  def self.flatten_helper(children); end
  def time; end
  def to_s; end
  def type; end
  include RecursivelyEnumerable
end
class Ole::Storage::FileClass
  def delete(*paths); end
  def directory?(path); end
  def dirent_from_path(path, orig_path = nil); end
  def exist?(path); end
  def exists?(path); end
  def expand_path(path); end
  def file?(path); end
  def initialize(ole); end
  def new(path, mode = nil); end
  def open(path, mode = nil, &block); end
  def read(path); end
  def rename(from_path, to_path); end
  def size(path); end
  def size?(path); end
  def stat(path); end
  def unlink(*paths); end
end
class Ole::Storage::FileClass::Stat
  def blksize; end
  def blocks; end
  def dev; end
  def directory?; end
  def file?; end
  def ftype; end
  def gid; end
  def initialize(dirent); end
  def ino; end
  def inspect; end
  def nlink; end
  def rdev; end
  def rdev_major; end
  def rdev_minor; end
  def size; end
  def size?; end
  def uid; end
end
class Ole::Storage::DirClass
  def chdir(orig_path); end
  def delete(path); end
  def dirent_from_path(path, orig_path = nil); end
  def entries(path); end
  def foreach(path, &block); end
  def getwd; end
  def initialize(ole); end
  def mkdir(path); end
  def new(path); end
  def open(path); end
  def pwd; end
  def rmdir(path); end
  def unlink(path); end
end
class Ole::Storage::DirClass::Dir
  def close; end
  def each(&block); end
  def initialize(path, entries); end
  def path; end
  def pos; end
  def pos=(pos); end
  def read; end
  def rewind; end
  def seek(pos); end
  def tell; end
  include Enumerable
end
class Ole::Storage::MetaData
  def [](key); end
  def []=(key, value); end
  def comp_obj; end
  def each(&block); end
  def file_format; end
  def initialize(ole); end
  def method_missing(name, *args, &block); end
  def mime_type; end
  def to_h; end
  include Enumerable
end
