{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.analyzeElementSiblings = analyzeElementSiblings;\n\nexports[\"default\"] = function (hierarchy, state, validateSelector) {\n  return hierarchy.reduce(function (selectorState, currentElem, index) {\n    if (!selectorState.verified) {\n      // get siblings BEFORE out element\n      var prevSiblings = currentElem.prevAll();\n      var nextSiblings = currentElem.nextAll // get element's index by the number of elements before it\n      // note that the nth-child selector uses a 1 based index, not 0\n      ();\n      var indexOfElement = prevSiblings.length + 1; // If the element has no siblings!\n      // we have no need for the nth-child selector\n\n      if ((prevSiblings.length || nextSiblings.length) && !analyzeElementSiblings(currentElem, [].concat(_toConsumableArray(prevSiblings), _toConsumableArray(nextSiblings)))) {\n        // if we don't have a unique tag or a unique class, then we need a nth-child to help us\n        // differenciate our element from the rest of the pack\n        selectorState.stack[index].push(':nth-child(' + indexOfElement + ')' // Verify the selector as we don't want to go on and parse the parent's siblings\n        // if we don't have to!\n        );\n        selectorState.verified = validateSelector(selectorState);\n      }\n    }\n\n    return selectorState;\n  }, state);\n};\n\nvar _lodash = require('lodash.difference');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _lodash3 = require('lodash.flatmap');\n\nvar _lodash4 = _interopRequireDefault(_lodash3);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * Inspect the element's siblings by index (nth-child) name and compare them to the analyzed element.\n * The sibling comparison is done from level 0 (the analyzed element) upwards in the hierarchy, In an effort to avoid unneeded parsing.\n * @param {array} hierarchy. The hierarchy of elements\n * @param {object} state. The current calculated CSS selector\n */\n\n\nvar not = function not(i) {\n  return !i;\n};\n\nvar getNodeNames = function getNodeNames(siblings) {\n  return siblings.map(function (sibling) {\n    return sibling.el.nodeName;\n  }\n  /***\n   * The main method splits up the hierarchy and isolates each element, while this helper method is designed\n   * to then take each level in the hierarchy and fid into it's surounding siblings.\n   * We've separated these to make the code more managable.\n   * @param siblingElement\n   * @param siblings\n   * @returns {boolean}\n   */\n  );\n};\n\nfunction analyzeElementSiblings(element, siblings) {\n  return (0, _lodash2[\"default\"])(element.getClasses(), (0, _lodash4[\"default\"])(siblings, function (sibling) {\n    return sibling.getClasses();\n  })).length > 0 || not(getNodeNames(siblings).includes(element.el.nodeName));\n}","map":null,"metadata":{},"sourceType":"module"}